和33题的解法2一样。总体思想就是查看nums[mid]和target是否在同一个单调区间。如果是的话，就套用传统的二分搜索，这个对于非严格递增的递增序列也是适用的。如果不是的话，则直接将搜索范围移向target所在单调区间。

和33题唯一的区别就是，当出现类似于1 1 1 2 3 4 0 1 1这种情况时，解决方法非常简单，就是将数组末尾的这些与nums[0]相同的数都去掉就行了。
```
int l=0,r=n-1;
while(l < r && nums[0] == nums[r]){
    r--;
}
```
同时，由于去除了单调数组末尾的这些与nums[0]相同的数，会引起新的问题。新的问题是在33题代码中 r 表示右数组的第一位元素，但是在此题中r 还可以为左数组的最后一个元素。
```
[2,2,2,3,2,2,2] 去除数组末尾的这些与nums[0]相同的数 -> nums[r] = 3 -> 左数组的最后一个元素
```
